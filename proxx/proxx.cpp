/**
* @file proxx.cpp
* @brief Прокси-сервер с логированием SQL запросов СУБД PostgreSQL в текстовый файл.
* @details 
* Ход работы: установлен PostgreSQL и pgAdmin на локальную машину Win.
* Порт сервера настроен на значение 5432, порт pgAdmin настроен на 5433.
* IP адрес настроен 127.0.0.1, использован IPv4.
* С pgAdmin делаем запросы, смотрим события на канале TCP Wireshark-ом, а также 
* видим взаимодействие на консоли, пишем лог в файл.
* Прокси ожидает соединения клиента, затем соединяется с сервером и ретранслирует 
* всю полученную информацию, при этом логирует запросы SQL с кодом запроса 'Q'.
* @todo Подумать насчет потокобезопасности, если в дальнейшем программу
* необходимо будет встраивать в многопоточное окружение.
*/

#include "tcp.h"

int main()
{
    /**
    * @todo Сделать проверку успешного создания объекта класса.
    */
    Tcp tcp;
    int res = tcp.init();
    if (res != 0)
    {
        tcp.deinit();
        return res;
    }

    /**
    * @brief Буфер и счетчик принятых байт для приема данных с TCP.
    * @todo Подумать о расширяемом буфере, так как согласно документации PostgreSQL
    * нет никакого ограничения на длину строки, которую может вернуть сервер. Необходимо
    * встроить блочный аллокатор памяти, размер блока должен быть 1 кБ 
    * (или кратный блоку TCP, MTU, etc.).
    * Использование malloc, new в системах реального времени нежелательно из-за 
    * проблем с производительностью.
    * @note В данном случае, размер буфера прокси ограничен 5 кБ.
    */
    const int buflen = 1024 * 5;
    char buf[buflen] = { 0 };

    /**
    * @todo Подумать, возможно переделать структуру программы.
    * В таком виде, когда показываем цикл в основном файле, более наглядно и
    * есть возможность в дальнейшем добавлять функционал.
    * Необходимо оценить, как из-за этого страдает производительность.
    */
    for (;;)
    {
        tcp.polling(buf, buflen); 
    }
}

