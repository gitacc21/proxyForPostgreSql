/**
* @file proxx.cpp
* @brief Прокси-сервер с логированием SQL запросов СУБД PostgreSQL в текстовый файл.
* @details 
* Ход работы: установлен PostgreSQL и pgAdmin на локальную машину Win.
* Порт сервера настроен на значение 5432, порт pgAdmin настроен на 5433.
* IP адрес настроен 127.0.0.1, использован IPv4.
* С pgAdmin делаем запросы, смотрим события на канале TCP Wireshark-ом, а также 
* видим взаимодействие на консоли, пишем лог в файл.
* Прокси ожидает соединения клиента, затем соединяется с сервером и ретранслирует 
* всю полученную информацию, при этом логирует запросы SQL с кодом запроса 'Q'.
* @note Приоритетным будет то соединение, которое в списке соединений
* имеет меньший индекс.
* @todo НАДО СДЕЛАТЬ
* 1. Протестировать на нагрузке. Были проведены тесты с pgAdmin, c netcat. Необходимо
* создать 30 соединений с прокси и посмотреть скорость обработки.
* 2. Использовать файловый дескриптор с записью в файл через read & write. Это
* даст возможность использовать select или poll для записи в файл.
* 3. Использовать неблокируемый ввод-вывод (TCP и в файл), так как это позволит максимально
* увеличить производительность, но приведет к усложнению кода и усложнению управления
* памятью.
* @todo
* Подумать насчет потокобезопасности, если в дальнейшем программу
* необходимо будет встраивать в многопоточное окружение.
*/

#include "tcp.h"

int main()
{
    /**
    * Для улучшения производительности ценой увеличения используемой RAM,
    * создадим отдельный буфер для TCP.
    * Если есть ограничение на RAM, возможно, необходимо откатиться до предыдущего
    * коммита.
    */
    /**
    * @brief Буфер и счетчик принятых байт для приема данных с TCP.
    * @todo Подумать о расширяемом буфере, так как согласно документации PostgreSQL
    * нет никакого ограничения на длину строки, которую может вернуть сервер. Необходимо
    * встроить блочный аллокатор памяти, размер блока должен быть 1 кБ
    * (или кратный блоку TCP, MTU, etc.).
    * Использование malloc, new в системах реального времени нежелательно из-за
    * проблем с производительностью.
    * @note В данном случае, размер буфера прокси ограничен 5 кБ.
    */
    static const int maxConn = 30; // Максимум 30 соединений к прокси.
    static const int buflen = 1024 * 5;
    static char buf[(maxConn * 2 + 1) * buflen] = { 0 };
    /**
    * @todo Проверять корректность *buf, так как в классе Tcp это должен быть 
    * корректный указатель и дополнительной проверки нет.
    */
    Tcp* tcp = new Tcp(maxConn, buflen, buf); 
    if (tcp == NULL) return -2000;
    int res = tcp->init();
    if (res != 0)
    {
        tcp->deinit();
        return res;
    }

    /**
    * @todo Подумать, возможно переделать структуру программы.
    * В таком виде, когда показываем цикл в основном файле, более наглядно и
    * есть возможность в дальнейшем добавлять функционал.
    * Необходимо оценить, как из-за этого страдает производительность.
    */
    for (;;)
    {
        tcp->polling(); 
    }
}

